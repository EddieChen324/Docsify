# 0-1背包

> 0-1背包指的是**有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。**



## 二维dp数组

明白数组**dp[i] [j]的含义**

> dp[i] [j]指的是在前i个（[0...i]）物品可以放入的情况下（可以放入，也可以不放入，但是放入也只能放入一次），容量为j的背包的最大价值
>
> 那么就有两种方向来推出dp[i] [j] 我们选择其中的最大值即可
>
> * 不放当前物品i
>
>   在该情况下，dp[i] [j] 的值与dp [i - 1] [j]的值相同，因为与当前物品i没有关系
>
> * 放当前物品i
>
>   既然要放入当前物品i，那么在放入之前的背包容量为j - weight[i]，我们用这些容量装入前i - 1个物品了，所以dp[i] [j] 的值就为dp[i] [j - weihgt[i]] + value[i]



**dp数组的初始化**

明确dp[i] [j]的含义，那么当j等于0时，无论前多少个物品都没有用，此时dp[i] [0]初始化为0

当j 小于weight[0]时，那么背包根本放不下去第一个物品，初始化为0，大于等于weight[0] 时，初始化为value[i] 即

```cpp
// 初始化 dp
vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
```



**遍历时顺序：先遍历物品，再遍历背包**





## 一维dp数组

**dp[j]表示容量为j的背包可放入物品的价值总和**

> 此时dp[j]取值也有两个选择：
>
> 一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，
>
> 所以递归公式为：
>
> ```text
> dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
> ```

**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**。

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？

看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。

**这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**。

那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。



**一维DP数组遍历背包顺序是倒序遍历的！这是为了让物品i只被放入一次**

**且一维DP数组遍历只能先遍历物品再遍历背包容量**







# 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。



完全背包的问题可以分为两类：

* 排列问题

  顺序不同则是新的结果。这里需要外层for遍历背包容量，内层for遍历物品

* 组合问题

  顺序不同，但是元素一样是同样的结果。这里需要外层for遍历物品，内层for遍历背包容量



关于dp数组的初始化

**看到求最小等字眼，dp[j]初始化最大值，dp[0]看情况而定，看到求最大等字眼，dp[j]都初始化为0**



递推公式分两类：

* 有多少种方法

  dp[j] += dp[j - nums[i]]

* 最值问题（常规的完全背包）

  dp[j] = max/min(dp[j], dp[j - weight[i]] + value[i])

